-- MAC上不用GPU的小型CNN测试
require("data.lua")
require 'torch'
lapp = require 'pl.lapp'
require 'nn'
require 'image'
require 'model.lua'
require 'train.lua'
require 'test.lua'
require 'paths'
function main()
-- 下载数据集
   -- data --
   cifar10.download()
   trainset = torch.load(cifar10.path_trainset_file)
   testset = torch.load(cifar10.path_testset_file)
   
   trainset.data = trainset.data:double() -- transfer the data across
   print('Training set:')
   print(trainset)
   testset.data = testset.data:double() -- transfer the data across
   
   print('Test set:')
   print(testset)

   setmetatable(trainset, 
       {
       __index = function(t, i) 
            return {t.data[i], t.label[i]} 
        end
       }
    );

   function trainset:size() 
     return self.data:size(1) 
   end
   print '==> preprocessing data: normalize each feature (channel) globally'
 ---Normalize data
    mean = {}
    stdv = {}
    for i=1,3 do
        mean[i] = trainset.data[{ {}, {i}, {}, {}  }]:mean()
        print('Channel ' .. i .. ', Mean: ' .. mean[i])
        trainset.data[{ {}, {i}, {}, {}  }]:add(-mean[i])

        stdv[i] = trainset.data[{ {}, {i}, {}, {}  }]:std()
        print('Channel ' .. i .. ', Standard Deviation:' .. stdv[i])
        trainset.data[{ {}, {i}, {}, {}  }]:div(stdv[i])
    end
   print(trainset:size())

      
   classes = {'airplane', 'automobile', 'bird', 'cat', 'deer', 'dog', 'frog', 'horse', 'ship', 'truck'}
   print('classes: ')
   print(classes)

-- 构建模型
   --net = model.constructModel(); 

   
   net = nn.Sequential()

   --change 1 channel to 3 channels
   --net:add(nn.SpatialConvolution(1, 6, 5, 5))
   net:add(nn.SpatialConvolution(3, 6, 5, 5)) 
   
   net:add(nn.ReLU())                       
   net:add(nn.SpatialMaxPooling(2,2,2,2))     
   net:add(nn.SpatialConvolution(6, 16, 5, 5))
   net:add(nn.ReLU())                       
   net:add(nn.SpatialMaxPooling(2,2,2,2))
   net:add(nn.View(16*5*5))                    
   net:add(nn.Linear(16*5*5, 120))         
   net:add(nn.ReLU())                       
   net:add(nn.Linear(120, 84))
   net:add(nn.ReLU())                       
   net:add(nn.Linear(84, 10))                  
   net:add(nn.LogSoftMax())    

   print(net)
   criterion = nn.ClassNLLCriterion();

   trainer = nn.StochasticGradient(net, criterion)
   trainer.learningRate = 0.001
   trainer.maxIteration = 10
   --print(trainset.label)
   trainset.label = trainset.label + 1 --原先的label是0-9，应该改成1-10
   trainer:train(trainset)


   --normalize test data

    for i = 1,3 do
        testset.data[{ {}, {i}, {}, {} }]:add(-mean[i])
        testset.data[{ {}, {i}, {}, {} }]:div(stdv[i])
    end
    testset.label = testset.label + 1 
    predicted = net:forward(testset.data[400])
    print(predicted:exp())


    --sort confidence and print predicted result
    confidences, indices = torch.sort(predicted, true)
    print(confidences[1])
    print(indices[1])
    print(classes[indices[1]])

    --correct rate in total
    correct = 0
    for i=1,10000 do
        local groundtruth = testset.label[i]
        local prediction = net:forward(testset.data[i])
        local confidences, indices = torch.sort(prediction, true)

        if groundtruth == indices[1] then
            correct = correct + 1
        end
    end
    print("correct rate in total")
    print(correct, 100*correct/10000 .. '%')


    --correct rate every class
    print("correct rate every class")
    class_performance = {0,0,0,0,0,0,0,0,0,0}
    for i = 1,10000 do
        local groundtruth = testset.label[i]
        local prediction = net:forward(testset.data[i])
        local confidences, indices = torch.sort(prediction, true)

        if groundtruth == indices[1] then
            class_performance[groundtruth] = class_performance[groundtruth] + 1
        end 
    end


    for i = 1, #classes do 
        print(classes[i], 100*class_performance[i]/1000 .. '%')
    end
end

main()